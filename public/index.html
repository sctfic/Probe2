<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Probe2 Météo</title>
<!-- Observable Plot -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.11/dist/plot.umd.js"></script>
<!-- External CSS and JS -->
<link rel="stylesheet" href="css/style.css">
<script src="js/miniPlot.js"></script>
<script src="js/sensorsMap.js"></script>
</head>
<body>
<header class="navbar">
    <div class="logo">
        <img src="img/probe-logo.png" alt="Probe Logo">
    </div>
    <nav>
        <ul>
            <li data-section="currents-section" class="active">Currents</li>
            <li data-section="historique-section">Historique</li>
            <li data-section="settings-section">Settings</li>
            <li data-section="new-station-section">New Station</li>
        </ul>
    </nav>
</header>

<!-- Sélecteur global de station -->
<div class="station-selector">
    <div class="station-info" id="station-info"></div>
    <div class="status-message" id="conditions-status" style="display: none;"></div>
    <select id="global-station-select">
        <option value="">Chargement des stations...</option>
    </select>
</div>

<main id="content-container" class="content-container">
    <section id="currents-section" class="content-section active">
        
        <!-- Contrôles de filtre réorganisés -->
        <div class="conditions-controls">
            <div class="filter-group">
                <input type="text" id="conditions-filter" placeholder="Rechercher une mesure..." value="">
            </div>
            <div class="conditions-stats" id="conditions-stats-display" style="display: none;"></div>
            <div class="view-group">
                <select id="conditions-group">
                    <option value="groupUsage" selected>Regroupement Fonctionnel</option>
                    <option value="measurement">Regroupement par Type de mesure</option>
                    <option value="groupCustom">Regroupement Personnel</option>
                    <option value="sensorDb">Regroupement par Type d'historique</option>
                    <option value="none">Aucun regroupement</option>
                </select>
            </div>
        </div>
        
        <div class="conditions-container" id="conditions-container">
            <!-- Les données météo seront chargées ici -->
        </div>
    </section>
    
    <section id="historique-section" class="content-section">
        <h1>Historique des Données</h1>
        <p>Afficher ici les graphiques et tableaux historiques pour la station sélectionnée.</p>
    </section>
    
    <section id="settings-section" class="content-section">
        <h1>Paramètres</h1>
        <div class="status-message" id="settings-status" style="display: none;"></div>
        
        <div id="settings-container">
            <!-- Le formulaire de configuration sera chargé ici -->
        </div>
    </section>
    
    <section id="new-station-section" class="content-section">
        <h1>Ajout d'une Station Météo</h1>
        <div class="stations-header">
            <button id="add-station-btn">Ajouter une station</button>
        </div>
        
        <!-- Modal pour ajouter/éditer une station -->
        <div id="station-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="modal-title">Ajouter une station</h2>
                <form id="station-form">
                    <input type="hidden" id="station-id">
                
                    <div class="form-group">
                        <label for="station-name">Nom *</label>
                        <input type="text" id="station-name" required>
                    </div>
                
                    <div class="form-group">
                        <label for="station-host">Hôte *</label>
                        <input type="text" id="station-host" required>
                    </div>
                
                    <div class="form-group">
                        <label for="station-port">Port *</label>
                        <input type="number" id="station-port" required>
                    </div>
                
                    <div class="form-group">
                        <label for="station-comment">Description</label>
                        <input type="text" id="station-comment">
                    </div>
                    
                    <div class="modal-actions">
                        <button type="button" id="cancel-station">Annuler</button>
                        <button type="submit">Enregistrer</button>
                    </div>
                </form>
            </div>
        </div>
    </section>
</main>

<script>

    document.addEventListener('DOMContentLoaded', () => {
        // Variables globales
        let globalStations = [];
        let selectedStation = null;
        let stationsConfig = {};
        let currentConditionsData = null;
        let allConditions = []; // Stocke toutes les conditions sans filtre
        let dbSensorList = null;

        // Éléments DOM
        const navItems = document.querySelectorAll('.navbar nav ul li');
        const sections = document.querySelectorAll('.content-section');
        const contentContainer = document.getElementById('content-container');
        const globalStationSelect = document.getElementById('global-station-select');
        const stationInfo = document.getElementById('station-info');
        let currentIndex = 0;

        // --- Gestion du sélecteur global de stations ---
        
        async function loadGlobalStations() {
            try {
                showStationStatus('Chargement des stations...', 'loading');
                const response = await fetch('/api/stations');
                if (!response.ok) throw new Error('Erreur de chargement des stations');
                
                const data = await response.json();
                if (data.success && data.stations) {
                    globalStations = data.stations;
                    populateStationSelector();
                    showStationStatus('', '');
                } else {
                    throw new Error('Format de réponse invalide');
                }
            } catch (error) {
                console.error('Erreur de chargement des stations:', error);
                showStationStatus('Erreur de chargement des stations', 'error');
                globalStationSelect.innerHTML = '<option value="">Erreur de chargement</option>';
            }
        }

        function populateStationSelector() {
            globalStationSelect.innerHTML = '<option value="">Sélectionner une station...</option>';
            
            globalStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station.id;
                option.textContent = station.name;
                option.dataset.location = station.location;
                option.dataset.host = station.host;
                option.dataset.port = station.port;
                globalStationSelect.appendChild(option);
            });

            // Sélectionner automatiquement la première station si disponible
            if (globalStations.length > 0) {
                globalStationSelect.value = globalStations[0].id;
                onStationChange();
            }
        }

        function onStationChange() {
            const selectedId = globalStationSelect.value;
            selectedStation = globalStations.find(s => s.id === selectedId) || null;
            
            if (selectedStation) {
                stationInfo.textContent = `${selectedStation.location} (${selectedStation.host}:${selectedStation.port})`;
                updateAllSectionInfo();
                refreshActiveSection();
            } else {
                stationInfo.textContent = '';
                clearAllSectionInfo();
            }
        }

        function updateAllSectionInfo() {
            // Fonction pour mettre à jour les informations de toutes les sections
        }

        function clearAllSectionInfo() {
            // Fonction pour effacer les informations de toutes les sections
        }

        function showStationStatus(message, type) {
            if (message) {
                console.log(`Station status [${type}]: ${message}`);
            }
        }

        function refreshActiveSection() {
            const activeSectionId = sections[currentIndex].id;
            
            if (activeSectionId === 'currents-section') {
                fetchCurrentConditions();
            } else if (activeSectionId === 'settings-section') {
                fetchStationSettings();
            }
        }

        // --- Section Données Actuelles ---
        
        async function fetchCurrentConditions() {
            if (!selectedStation) {
                showConditionsStatus('Aucune station sélectionnée', 'error');
                return;
            }

            showConditionsStatus('Chargement des données météo...', 'loading');

            let data, api0;
            try {
                try {
                    api0 = await fetch(`/api/station/${selectedStation.id}/current-conditions`, { cache: 'no-cache' });
                    if (!api0.ok) {
                        throw new Error(`HTTP error! status: ${api0.status}`);
                    }
                } catch (error) {
                    console.warn('Données mock chargées', error.message);
                    api0 = await fetch(`/mock/station/current-conditions.json`);
                }

                data = await api0.json();                
                const api1 = await fetch(`/query/${selectedStation.id}`);
                if (!api1.ok) console.log('Erreur de récupération des _field');
                dbSensorList = await api1.json();
                console.log('dbSensorList', dbSensorList);

                if (data.success && data.data) {
                    currentConditionsData = data.data;
                    processAndDisplayConditions();
                    showConditionsStatus('Données actualisées avec succès', 'success');
                } else {
                    throw new Error('Format de données invalide');
                }
            } catch (error) {
                console.error('Erreur:', error);
                showConditionsStatus(`Erreur: ${error.message}`, 'error');
                const conditionsList = document.getElementById('conditions-list');
                if (conditionsList) conditionsList.innerHTML = '';
            }
        }

        function processAndDisplayConditions() {
            if (!currentConditionsData) return;

            // Convertir les données en tableau et exclure certains champs
            const excludeKeys = ['datagramme', 'timestamp'];
            allConditions = Object.entries(currentConditionsData)
                .filter(([key]) => !excludeKeys.includes(key))
                .map(([key, data]) => {
                    const sensorInfo = sensorMap[key] || {};
                    return {
                        key,
                        name: sensorInfo.label || formatLabel(key),
                        rawData: data,
                        value: extractValue(data),
                        unit: extractUnit(data),
                        measurement: sensorInfo.measurement || 'unknown',
                        groupUsage: sensorInfo.groupUsage || '0',
                        groupCustom: sensorInfo.groupCustom || 0,
                        period: sensorInfo.period || '3d',
                        sensorDb: sensorInfo.sensorDb,
                        searchText: `${sensorInfo.label || formatLabel(key)} ${extractValue(data)} ${extractUnit(data)}`.toLowerCase()
                    };
                });
    console.log('allConditions', allConditions);
            // Afficher les conditions selon le groupement
            displayConditions();
            
            // Appliquer le filtre en cours
            applyCurrentFilter();

            // Charger les graphiques après affichage
            setTimeout(() => {
                loadAllCharts();
            }, 100);
        }

        // Nouvelle fonction pour appliquer le filtre sans recharger
        function applyCurrentFilter() {
            const filterText = document.getElementById('conditions-filter')?.value?.toLowerCase() || '';
            const tiles = document.querySelectorAll('.condition-tile');
            
            let visibleCount = 0;
            
            tiles.forEach(tile => {
                const conditionKey = tile.dataset.key;
                const condition = allConditions.find(c => c.key === conditionKey);
                
                if (!condition) return;
                
                const isVisible = filterText === '' || condition.searchText.includes(filterText);
                
                if (isVisible) {
                    tile.style.display = '';
                    visibleCount++;
                } else {
                    tile.style.display = 'none';
                }
            });

            // Mise à jour des stats avec le nouveau système
            updateConditionsStats(visibleCount);
            
            // Gestion des groupes vides
            updateGroupVisibility();
        }

        function updateGroupVisibility() {
            const groups = document.querySelectorAll('.unit-group');
            
            groups.forEach(group => {
                const visibleTiles = group.querySelectorAll('.condition-tile[style=""], .condition-tile:not([style*="display: none"])');
                const hasVisibleTiles = Array.from(group.querySelectorAll('.condition-tile')).some(tile => 
                    tile.style.display !== 'none'
                );
                
                if (hasVisibleTiles) {
                    group.style.display = '';
                    // Mettre à jour le compteur du groupe
                    const counter = group.querySelector('.unit-count');
                    if (counter) {
                        counter.textContent = visibleTiles.length;
                    }
                } else {
                    group.style.display = 'none';
                }
            });
        }

        function updateConditionsStats(visibleCount) {
            const statsEl = document.getElementById('conditions-stats-display');
            
            if (statsEl && currentConditionsData) {
                const totalCount = Object.keys(currentConditionsData).length;
                const visibleConditions = allConditions.filter((_, index) => {
                    const tile = document.querySelector(`.condition-tile[data-key="${allConditions[index].key}"]`);
                    return tile && tile.style.display !== 'none';
                });
                const unitsCount = new Set(visibleConditions.map(item => item.unit)).size;
                
                statsEl.innerHTML = `${visibleCount} / ${totalCount} mesures • ${unitsCount} types`;
                statsEl.style.display = 'block';
            }
        }

        function extractValue(data) {
            if (!data) return 'N/A';
            if (typeof data === 'object' && data.Value !== undefined) {
                return data.Value;
            }
            return data.toString();
        }

        function extractUnit(data) {
            if (!data) return '';
            if (typeof data === 'object' && data.Unit !== undefined) {
                return data.Unit;
            }
            return '';
        }

        function displayConditions() {
            const groupBy = document.getElementById('conditions-group')?.value || 'unit';
            
            if (groupBy === 'none') {
                reorganizeConditionsList();
            } else {
                reorganizeConditionsGrouped(groupBy);
            }
        }

        function reorganizeConditionsGrouped(groupBy) {
            const conditionsContainer = document.getElementById('conditions-container');
            if (!conditionsContainer) return;

            if (allConditions.length === 0) {
                conditionsContainer.innerHTML = '<div class="conditions-grid"><div class="no-results">Aucune donnée ne correspond à votre recherche.</div></div>';
                return;
            }

            // Détacher les tuiles existantes du DOM pour les préserver
            const existingTiles = {};
            document.querySelectorAll('.condition-tile').forEach(tile => {
                const key = tile.dataset.key;
                if (key) {
                    tile.remove(); // Retirer du DOM mais garder la référence
                    existingTiles[key] = tile;
                }
            });

            // Grouper selon le critère
            const groupedData = allConditions.reduce((groups, item) => {
                let groupKey;
                switch (groupBy) {
                    case 'measurement':
                        groupKey = item.measurement || 'Sans type';
                        break;
                    case 'groupUsage':
                        groupKey = item.groupUsage;
                        break;
                    case 'groupCustom':
                        groupKey = item.groupCustom;
                        break;
                    default:
                        groupKey = item.sensorDb || 'Sans historique!';
                        break;
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(item);
                return groups;
            }, {});

            // Créer la nouvelle structure
            let newHTML = '';
            Object.entries(groupedData).sort((a, b) => a[0].localeCompare(b[0])).forEach(([groupName, items]) => {
                newHTML += `
                    <div class="unit-group">
                        <h3>
                            ${groupName}
                            <span class="unit-count">${items.length}</span>
                        </h3>
                        <div class="conditions-grid" data-group="${groupName}">
                        </div>
                    </div>
                `;
            });

            conditionsContainer.innerHTML = newHTML;

            // Réinsérer les tuiles existantes dans les bons groupes
            Object.entries(groupedData).forEach(([groupName, items]) => {
                const groupGrid = conditionsContainer.querySelector(`[data-group="${groupName}"]`);
                if (groupGrid) {
                    items.forEach(item => {
                        if (existingTiles[item.key]) {
                            // Réinsérer la tuile existante avec ses graphiques
                            groupGrid.appendChild(existingTiles[item.key]);
                        } else {
                            // Créer une nouvelle tuile seulement si elle n'existe pas
                            const tileElement = document.createElement('div');
                            tileElement.innerHTML = createConditionTileHTML(item);
                            groupGrid.appendChild(tileElement.firstElementChild);
                            // Charger le graphique pour cette nouvelle tuile
                            setTimeout(() => {
                                if (item.sensorDb && dbSensorList && dbSensorList.data && dbSensorList.data._field && 
                                    dbSensorList.data._field.includes(item.sensorDb)) {
                                    const chartId = `chart_${item.key}`;
                                    const param = `stepCount=${item.measurement === 'rain' ? 12 : 240}&startDate=${getStartDate(item.period)}`;
                                    loadData(chartId, `${API_BASE_URL}/${selectedStation.id}/Raw/${item.sensorDb}?${param}`);
                                }
                            }, 50);
                        }
                    });
                }
            });
        }

        function reorganizeConditionsList() {
            const conditionsContainer = document.getElementById('conditions-container');
            if (!conditionsContainer) return;

            if (allConditions.length === 0) {
                conditionsContainer.innerHTML = '<div class="conditions-grid"><div class="no-results">Aucune donnée ne correspond à votre recherche.</div></div>';
                return;
            }

            // Détacher les tuiles existantes du DOM pour les préserver
            const existingTiles = {};
            document.querySelectorAll('.condition-tile').forEach(tile => {
                const key = tile.dataset.key;
                if (key) {
                    tile.remove(); // Retirer du DOM mais garder la référence
                    existingTiles[key] = tile;
                }
            });

            // Créer la nouvelle structure
            const newHTML = '<div class="conditions-grid" data-ungrouped="true"></div>';
            conditionsContainer.innerHTML = newHTML;

            const grid = conditionsContainer.querySelector('[data-ungrouped="true"]');
            
            // Réinsérer les tuiles existantes
            allConditions.forEach(item => {
                if (existingTiles[item.key]) {
                    // Réinsérer la tuile existante avec ses graphiques
                    grid.appendChild(existingTiles[item.key]);
                } else {
                    // Créer une nouvelle tuile seulement si elle n'existe pas
                    const tileElement = document.createElement('div');
                    tileElement.innerHTML = createConditionTileHTML(item);
                    grid.appendChild(tileElement.firstElementChild);
                    // Charger le graphique pour cette nouvelle tuile
                    setTimeout(() => {
                        if (item.sensorDb && dbSensorList && dbSensorList.data && dbSensorList.data._field && 
                            dbSensorList.data._field.includes(item.sensorDb)) {
                            const chartId = `chart_${item.key}`;
                            const param = `stepCount=${item.measurement === 'rain' ? 12 : 240}&startDate=${getStartDate(item.period)}`;
                            loadData(chartId, `${API_BASE_URL}/${selectedStation.id}/Raw/${item.sensorDb}?${param}`);
                        }
                    }, 50);
                }
            });
        }

        function createConditionTileHTML(item) {
            let displayValue = item.value;
            let metaInfo = '';

            // Gérer les cas spéciaux
            if (item.rawData && typeof item.rawData === 'object') {
                if (item.rawData.Value !== undefined) {
                    if (item.rawData.message && item.rawData.Type) {
                        metaInfo = `<div class="condition-meta">${item.rawData.Type}: ${item.rawData.message}</div>`;
                    }
                }
            }

            let unitDisplay = item.unit ? `<span class="condition-unit">${dbSensorList?.metadata?.unit?.[item.measurement]?.unit || item.unit}</span>` : '';
            
            let chartContent = '';
            if (item.key === 'ForecastNum') {// Cas spécial pour ForecastIcon - afficher des images météo
                const weatherImages = displayValue.split(' ');
                chartContent = `
                    <div class="weather-forecast-container">
                        ${weatherImages.map(weather => `
                            <img src="img/${weather}.png" 
                                 alt="${weather}" 
                                 class="weather-icon weather-${weather.toLowerCase()} ${displayValue === weather ? 'active' : ''}"
                                 style="z-index: ${weather === 'Cloud' ? 3 : weather === 'Rain' ? 4 : weather === 'Snow' ? 5 : 2}">
                        `).join('')}
                    </div>
                `;
                unitDisplay = '';
            } else if (item.measurement === 'direction'){ // Cas spécial pour afficher une flèche directionnelle 
                const windDirection = parseFloat(displayValue) || 135;
                // Calculer la position sur le cercle (rayon 100px)
                const angleRad = (windDirection - 90) * Math.PI / 180; // -90 pour que 0° soit en haut
                const radius = 64;
                const x = Math.cos(angleRad) * radius;
                const y = Math.sin(angleRad) * radius;
                
                chartContent = `
                    <div class="wind-compass">
                        <img src="img/windRose.png" alt="Rose des vents" class="wind-rose">
                        <img src="img/windArrow.png" alt="Direction du vent" class="wind-arrow" 
                            style="transform: translate(calc(-50% + ${x}px), calc(-50% + ${y}px)) rotate(${windDirection}deg)">
                    </div>
                    <!-- div class="wind-controls">
                        <label class="label-input" style="display:flex;">
                            <span style="display:inline-block;width:7em;">angle:</span>
                            <input type="range" value="${windDirection}" min="0" max="360" step="22.5" 
                                onchange="updateWindDirection(this, '${item.key}')">
                            <span style="font-variant-numeric:tabular-nums;" class="angle-display">${Math.round(windDirection)}°</span>
                        </label>
                    </div -->
                `;
                unitDisplay = '';
            } else if (item.unit === 'dateStormRain') {
                unitDisplay = '';
            } else {
                chartContent = `<div id="chart_${item.key}" class="plot-container"></div>`;
            }
            
            const fn = eval(dbSensorList?.metadata?.unit?.[item.measurement]?.avaible_units?.[item.unit]?.fnFromMetric || 'x => x');
            return `
                <div class="condition-tile" data-key="${item.key}">
                    <div class="condition-content">
                        <div class="condition-info">
                            <div class="condition-name">${item.name}</div>
                            <div class="condition-value">
                                ${fn(displayValue)} ${unitDisplay}
                            </div>
                            ${metaInfo}
                        </div>
                        <div class="condition-chart">
                            ${chartContent}
                        </div>
                    </div>
                </div>
            `;
        }

        function getStartDate (period){
            if (period === 'dateStormRain') return currentConditionsData.dateStormRain.Value;
            return Math.round((new Date()).getTime()/1000) - period;
        }

        function loadAllCharts() {
            if (!selectedStation || !dbSensorList) return;

            allConditions.forEach(item => {
                if (item.sensorDb && dbSensorList.data && dbSensorList.data._field && 
                    dbSensorList.data._field.includes(item.sensorDb)) {
                    const chartId = `chart_${item.key}`;
                    const param = `stepCount=${item.measurement === 'rain' ? 12 : 240}&startDate=${getStartDate(item.period)}`;
                    loadData(chartId, `${API_BASE_URL}/${selectedStation.id}/Raw/${item.sensorDb}?${param}`);
                }
            });
        }

        function formatLabel(key) {
            const labelMap = {
                'barometer': 'Baromètre',
                'inTemp': 'Température intérieure',
                'inHumidity': 'Humidité intérieure',
                'outTemp': 'Température extérieure',
                'windSpeed': 'Vitesse du vent',
                'windSpeedMax': 'Vitesse du vent max',
                'avgWindSpeed10Min': 'Vitesse vent moyenne (10min)',
                'windDir': 'Direction du vent',
                'windDirMax': 'Direction du vent max',
                'outHumidity': 'Humidité extérieure',
                'rainRate': 'Taux de précipitation',
                'UV': 'Index UV',
                'solarRadiation': 'Puissance Radiation solaire',
                'stormRain': "Dernières précipitations d'averses",
                'dayRain': 'Pluie du jour',
                'monthRain': 'Pluie du mois',
                'yearRain': 'Pluie de l\'année',
                'dayET': 'Évapotranspiration du jour',
                'monthET': 'Évapotranspiration du mois',
                'yearET': 'Évapotranspiration de l\'année',
                'batteryVoltage': 'Voltage batterie',
                'ForecastIcon': 'Prévision météo',
                'sunrise': 'Lever du soleil',
                'sunset': 'Coucher du soleil',
                'avgWindSpeed2Min': 'Vitesse vent moyenne (2min)',
                'windGust10Min': 'Rafale de vent (10min)',
                'windGustDir10Min': 'Direction rafale (10min)',
                'dewPoint': 'Point de rosée',
                'heatIndex': 'Indice de chaleur',
                'windChill': 'Refroidissement éolien',
                'THSW': 'Indice THSW',
                'dateStormRain': 'Date de début des dernières averses',
                'last15MinRain': 'Pluie (15 dernières min)',
                'lastHourRain': 'Pluie (dernière heure)',
                'last24HourRain': 'Pluie (24 dernières heures)'
            };
            
            return labelMap[key] || key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        }

        function showConditionsStatus(message, type) {
            const statusEl = document.getElementById('conditions-status');
            if (!statusEl) return;

            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = message ? 'block' : 'none';

            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // --- Section Paramètres (Settings) ---
        
        let currentStationSettings = null;

        async function fetchStationSettings() {
            if (!selectedStation) {
                showSettingsStatus('Aucune station sélectionnée', 'error');
                return;
            }

            showSettingsStatus('Chargement des paramètres...', 'loading');

            try {
                const response = await fetch(`/api/station/${selectedStation.id}`);
                if (!response.ok) throw new Error('Erreur de récupération des paramètres');
                
                const data = await response.json();
                if (data.success && data.settings) {
                    currentStationSettings = data.settings;
                    displaySettingsForm();
                    showSettingsStatus('Paramètres chargés avec succès', 'success');
                } else {
                    throw new Error('Format de données invalide');
                }
            } catch (error) {
                console.error('Erreur:', error);
                showSettingsStatus(`Erreur: ${error.message}`, 'error');
                document.getElementById('settings-container').innerHTML = '';
            }
        }

        function displaySettingsForm() {
            const settingsContainer = document.getElementById('settings-container');
            if (!settingsContainer || !currentStationSettings) return;

            const excludeKeys = ['id', 'lastArchiveDate', 'deltaTimeSeconds', 'path'];
            
            const groups = {
                identity: {
                    title: 'Identité',
                    fields: ['name', 'location', 'comment']
                },
                network: {
                    title: 'Configuration Réseau',
                    fields: ['host', 'port']
                },
                localisation: {
                    title: 'Localisation',
                    fields: ['longitude', 'latitude', 'longitudeEastWest', 'latitudeNorthSouth', 'altitude']
                },
                meteo: {
                    title: 'Station Météo',
                    fields: ['archiveInterval','AMPMMode', 'dateFormat', 'windCupSize', 'rainCollectorSize', 'rainSaisonStart']
                }
            };

            let formHTML = '<form id="station-settings-form" class="settings-form">';
            
            Object.entries(groups).forEach(([groupKey, group]) => {
                formHTML += `
                    <div class="settings-group">
                        <h3>${group.title}</h3>
                        <div class="settings-row">
                `;
                
                group.fields.forEach(fieldKey => {
                    if (currentStationSettings.hasOwnProperty(fieldKey) && !excludeKeys.includes(fieldKey)) {
                        const field = currentStationSettings[fieldKey];
                        formHTML += createSettingFieldHTML(fieldKey, field);
                    }
                });
                
                formHTML += `
                        </div>
                    </div>
                `;
            });

            formHTML += `
                <div class="settings-actions">
                    <button type="button" class="btn-secondary" id="reset-settings">Annuler</button>
                    <button type="submit">Enregistrer</button>
                </div>
            </form>
            `;

            settingsContainer.innerHTML = formHTML;

            const form = document.getElementById('station-settings-form');
            const resetBtn = document.getElementById('reset-settings');

            if (form) {
                form.addEventListener('submit', handleSettingsSubmit);
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    displaySettingsForm();
                });
            }
        }

        function createSettingFieldHTML(key, field) {
            const label = formatSettingLabel(key);
            let value = '';
            let tooltip = '';

            if (typeof field === 'object' && field !== null) {
                value = field.desired !== undefined ? field.desired : field.value || '';
                
                const tooltipParts = [];
                if (field.comment) tooltipParts.push(field.comment);
                if (field.lastReadValue !== undefined) tooltipParts.push(`Valeur actuelle: ${field.lastReadValue}`);
                tooltip = tooltipParts.join(' | ');
            } else {
                value = field;
            }

            const inputType = getInputTypeForField(key, value);
            const tooltipHTML = tooltip ? `<span class="tooltip" data-tooltip="${tooltip}">?</span>` : '';

            return `
                <div class="settings-field">
                    <label for="setting-${key}">
                        ${label}
                        ${tooltipHTML}
                    </label>
                    ${createInputHTML(key, value, inputType)}
                </div>
            `;
        }

        function createInputHTML(key, value, inputType) {
            if (inputType === 'select') {
                return createSelectHTML(key, value);
            }

            return `<input type="${inputType}" id="setting-${key}" name="${key}" value="${value}" ${key=='timezone'?'readonly':''}>`;
        }

        function createSelectHTML(key, value) {
            const selectOptions = {
                'AMPMMode': [
                    { value: 0, label: 'AM/PM' },
                    { value: 1, label: '24h' }
                ],
                'dateFormat': [
                    { value: 0, label: 'Mois/Jour' },
                    { value: 1, label: 'Jour/Mois' }
                ],
                'windCupSize': [
                    { value: 0, label: 'Petit' },
                    { value: 1, label: 'Grand' }
                ],
                'rainCollectorSize': [
                    { value: 0, label: '0.01in' },
                    { value: 1, label: '0.2mm' },
                    { value: 2, label: '0.1mm' }
                ],
                'latitudeNorthSouth': [
                    { value: 0, label: 'Sud' },
                    { value: 1, label: 'Nord' }
                ],
                'longitudeEastWest': [
                    { value: 0, label: 'Est' },
                    { value: 1, label: 'Ouest' }
                ],
                'archiveInterval': [
                    { value: 1, label: '1 min' },
                    { value: 5, label: '5 min' },
                    { value: 10, label: '10 min' },
                    { value: 15, label: '15 min' },
                    { value: 30, label: '30 min' },
                    { value: 60, label: '1 heure' },
                    { value: 120, label: '2 heures' }
                ]
            };

            if (!selectOptions[key]) return `<input type="text" id="setting-${key}" name="${key}" value="${value}">`;

            let optionsHTML = '';
            selectOptions[key].forEach(option => {
                const selected = option.value == value ? 'selected' : '';
                optionsHTML += `<option value="${option.value}" ${selected}>${option.label}</option>`;
            });

            return `<select id="setting-${key}" name="${key}">${optionsHTML}</select>`;
        }

        function getInputTypeForField(key, value) {
            if (['AMPMMode', 'archiveInterval', 'dateFormat', 'windCupSize', 'rainCollectorSize', 'latitudeNorthSouth', 'longitudeEastWest'].includes(key)) {
                return 'select';
            }
            if (['port', 'rainSaisonStart'].includes(key)) {
                return 'number';
            }
            if (['longitude', 'latitude', 'altitude'].includes(key)) {
                return 'number';
            }
            return 'text';
        }

        function formatSettingLabel(key) {
            const labelMap = {
                'name': 'Nom de la station',
                'archiveInterval': 'Intervalle archive (min)',
                'comment': 'Description',
                'host': 'Adresse IP/Host',
                'port': 'Port',
                'location': 'Emplacement',
                'longitude': 'Longitude',
                'latitude': 'Latitude',
                'altitude': 'Altitude (m)',
                'AMPMMode': 'Format heure',
                'dateFormat': 'Format date',
                'windCupSize': 'Taille anémomètre',
                'rainCollectorSize': 'Taille pluviomètre',
                'rainSaisonStart': 'Mois début saison pluie',
                'latitudeNorthSouth': 'Latitude Nord/Sud',
                'longitudeEastWest': 'Longitude Est/Ouest'
            };
            
            return labelMap[key] || key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        }

        async function handleSettingsSubmit(e) {
            e.preventDefault();
            if (!selectedStation) return;

            const formData = new FormData(e.target);
            const settings = {};

            for (let [key, value] of formData.entries()) {
                const currentField = currentStationSettings[key];
                
                if (typeof currentField === 'object' && currentField !== null) {
                    settings[key] = {
                        ...currentField,
                        desired: isNaN(value) ? value : Number(value)
                    };
                } else {
                    settings[key] = isNaN(value) ? value : Number(value);
                }
            }

            showSettingsStatus('Enregistrement des paramètres...', 'loading');

            try {
                const response = await fetch(`/api/station/${selectedStation.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });

                const result = await response.json();
                if (!result.success) throw new Error('Erreur lors de la sauvegarde');

                showSettingsStatus('Synchronisation avec la station...', 'loading');

                const syncResponse = await fetch(`/api/station/${selectedStation.id}/sync-settings`);
                const syncResult = await syncResponse.json();
                if (!syncResult.success) {
                    console.warn('Avertissement synchronisation:', syncResult.message || 'Erreur inconnue');
                }

                showSettingsStatus('Mise à jour de la date/heure...', 'loading');

                const datetimeResponse = await fetch(`/api/station/${selectedStation.id}/update-datetime`);
                const datetimeResult = await datetimeResponse.json();
                if (!datetimeResult.success) {
                    console.warn('Avertissement mise à jour date/heure:', datetimeResult.message || 'Erreur inconnue');
                }

                showSettingsStatus('Paramètres sauvegardés et synchronisés avec succès', 'success');
                
                setTimeout(() => {
                    fetchStationSettings();
                }, 2000);

            } catch (error) {
                console.error('Erreur:', error);
                showSettingsStatus(`Erreur: ${error.message}`, 'error');
            }
        }

        function showSettingsStatus(message, type) {
            const statusEl = document.getElementById('settings-status');
            if (!statusEl) return;

            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = message ? 'block' : 'none';

            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 5000);
            }
        }

        // --- Navigation Logic ---
        
        function updateView() {
            if (contentContainer) {
                contentContainer.style.transform = `translateX(-${currentIndex * 100}vw)`;
            }

            navItems.forEach((item, index) => {
                if (index === currentIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            refreshActiveSection();
        }

        navItems.forEach((item, index) => {
            item.addEventListener('click', () => {
                currentIndex = index;
                if (contentContainer) {
                    contentContainer.style.transition = 'transform 0.3s ease-out';
                    updateView();
                    setTimeout(() => { contentContainer.style.transition = ''; }, 300);
                }
            });
        });

        // --- Gestion du swipe ---
        let startX = 0;
        let endX = 0;
        let isSwiping = false;

        if (contentContainer) {
            contentContainer.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isSwiping = true;
            });

            contentContainer.addEventListener('touchmove', (e) => {
                if (!isSwiping) return;
                e.preventDefault();
                endX = e.touches[0].clientX;
                const diffX = startX - endX;
                contentContainer.style.transform = `translateX(calc(-${currentIndex * 100}vw - ${diffX}px))`;
            });

            contentContainer.addEventListener('touchend', () => {
                if (!isSwiping) return;
                isSwiping = false;
                const diffX = startX - endX;

                if (diffX > 50 && currentIndex < sections.length - 1) {
                    currentIndex++;
                } else if (diffX < -50 && currentIndex > 0) {
                    currentIndex--;
                }
                
                if (contentContainer) {
                    contentContainer.style.transition = 'transform 0.3s ease-out';
                    updateView();
                    setTimeout(() => {
                        contentContainer.style.transition = '';
                    }, 300);
                }
            });
        }

        // --- Event Listeners ---
        
        if (globalStationSelect) {
            globalStationSelect.addEventListener('change', onStationChange);
        }

        const refreshConditionsBtn = document.getElementById('refresh-conditions');
        if (refreshConditionsBtn) {
            refreshConditionsBtn.addEventListener('click', fetchCurrentConditions);
        }

        const conditionsFilter = document.getElementById('conditions-filter');
        const conditionsGroup = document.getElementById('conditions-group');

        // Nouveau comportement pour le filtre - pas de rechargement des données
        if (conditionsFilter) {
            conditionsFilter.addEventListener('input', applyCurrentFilter);
        }

        if (conditionsGroup) {
            conditionsGroup.addEventListener('change', () => {
                displayConditions();
                applyCurrentFilter();
            });
        }

        // --- Initialisation ---
        
        loadGlobalStations();
        updateView();
    });

</script>
</body>
</html>